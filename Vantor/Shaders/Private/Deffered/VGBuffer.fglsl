#version 460 core

layout (location = 0) out vec4 gAlbedoSpec;  // RGB = Albedo, A = Specular (or unused)
layout (location = 1) out vec3 gNormal;      // World-space normal
layout (location = 2) out vec4 gMaterial;    // R = Metallic, G = Roughness, B = AO
layout (location = 3) out vec3 gPosition;    // World-space position

in vec2 TexCoords;
in vec3 FragPos;
in mat3 TBN; // Tangent-Bitangent-Normal matrix (from vertex shader)

// Uniforms
uniform sampler2D VTextureDiffuse;
uniform sampler2D VTextureNormal;
uniform sampler2D VTextureMetallic;
uniform sampler2D VTextureRoughness;
uniform sampler2D VTextureAO;
uniform sampler2D VTextureHeight;

uniform vec3 VColor; // Fallback diffuse color
uniform bool VUseDiffuseTexture;
// PBR
uniform bool VUseNormalTexture;
uniform bool VUseMetallicTexture;
uniform bool VUseRoughnessTexture;
uniform bool VUseAOTexture;
// Other
uniform bool VUseParallaxMapping;

uniform vec3 CameraPosition;
uniform float VHeightScale = 1.0; // TODO: Make adjustable by the user

#include <Vantor/VCommon.hglsl>

// === Parallax Mapping Function ===
vec2 ParallaxUV(vec2 texCoords, vec3 viewDirTangent)
{
    float height = texture(VTextureHeight, texCoords).r;
    return texCoords - viewDirTangent.xy * (height * VHeightScale);
}

// === Get Normal (with adjusted UV) ===
vec3 getNormalFromMap(vec2 adjustedUV)
{
    if (VUseNormalTexture) {
        vec3 tangentNormal = texture(VTextureNormal, adjustedUV).rgb;
        tangentNormal = tangentNormal * 2.0 - 1.0;
        return normalize(TBN * tangentNormal);
    } else {
        // fallback
       return normalize(TBN[2]);
    }
}

void main()
{
    // === View direction in tangent space ===
    vec3 viewDir = normalize(CameraPosition - FragPos);
    vec3 viewDirTangent = normalize(TBN * viewDir);

    vec2 adjustedUV;

    if (VUseParallaxMapping) {
        adjustedUV = ParallaxUV(TexCoords, viewDirTangent);
    } else {
        adjustedUV = TexCoords;
    }

    // === Sample Textures with Adjusted UVs or fallback values ===
    vec3 albedo = VUseDiffuseTexture 
        ? texture(VTextureDiffuse, adjustedUV).rgb 
        : VColor;

    float metallic  = VUseMetallicTexture 
        ? texture(VTextureMetallic, adjustedUV).r 
        : 0.0;

    float roughness = VUseRoughnessTexture 
        ? texture(VTextureRoughness, adjustedUV).r 
        : 1.0;

    float ao = VUseAOTexture 
        ? max(texture(VTextureAO, adjustedUV).r, 0.001) 
        : 1.0;

    // === Output ===
    gAlbedoSpec.rgb = albedo;
    gAlbedoSpec.a = 1.0; // TODO: Calculate Specular

    gNormal = getNormalFromMap(adjustedUV);
    gMaterial = vec4(metallic, roughness, ao, 1.0);
    gPosition = FragPos;
}
